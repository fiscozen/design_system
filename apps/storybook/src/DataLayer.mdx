import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Documentation/DataLayer" />

# Data Layer - @fiscozen/data

Documentation for **developers using the package** in their applications (installation, setup, API, examples). For package maintainers, see the README in `packages/data`.

Complete guide for using the `@fiscozen/data` package in your Vue 3 application.

## Table of Contents

1. [Introduction](#introduction)
2. [Installation](#installation)
3. [Setup](#setup)
4. [API Quick Reference](#api-quick-reference)
5. [Usage Pattern](#usage-pattern)
6. [Custom Actions & Merge Helpers](#custom-actions--merge-helpers)
7. [Nested and custom routes](#nested-and-custom-routes)
8. [Actions Reference](#actions-reference)
9. [Error Handling Patterns](#error-handling-patterns)
10. [TypeScript Best Practices](#typescript-best-practices)
11. [Testing](#testing)
12. [Features](#features)
13. [Future Enhancements](#future-enhancements)
14. [Summary](#summary)

---

## Introduction

The `@fiscozen/data` package provides a **structured data layer** for Vue 3 applications that:

- **Keeps components clean** - No embedded API logic in your Vue components
- **Provides reactive state management** - Automatic refetching when parameters change
- **Centralizes error handling** - Consistent error states across your app
- **Ensures type safety** - Full TypeScript support with generics
- **Simplifies CRUD operations** - Standardized patterns for all entities

### The Pattern

The package follows a **layered architecture**:

1. **Setup** (once at app initialization) - Configure base URL, CSRF, interceptors
2. **Entity Composable** (once per entity) - Create a composable that wraps `useActions` for your entity
3. **Component Usage** - Use the entity composable in your Vue components

This pattern ensures:
- **Consistency** - All entities follow the same structure
- **Reusability** - Entity composables can be used across multiple components
- **Testability** - Easy to mock and test entity composables
- **Maintainability** - Changes to API structure are centralized

---

## Installation

```bash
npm install @fiscozen/data
```

---

## Setup

Configure the data layer **once** at your app initialization (typically in `main.ts` or your app setup file).

### Basic Setup

```typescript
import { setupFzFetcher } from '@fiscozen/data/rest'

setupFzFetcher({
  baseUrl: 'https://api.example.com/v1',
  csrf: {
    enabled: true,
    cookieName: 'csrf_token',
    headerName: 'X-CSRF-Token'
  }
})
```

### Complete Setup Options

```typescript
import { setupFzFetcher } from '@fiscozen/data/rest'

setupFzFetcher({
  // Required: Base URL for all API requests
  baseUrl: 'https://api.example.com/v1',
  
  // CSRF Protection (optional)
  csrf: {
    enabled: true,              // Enable CSRF token injection
    cookieName: 'csrf_token',   // Cookie name containing CSRF token
    headerName: 'X-CSRF-Token'  // Header name to send CSRF token
  },
  
  // Request Deduplication (optional)
  deduplication: true,  // Enable globally (can be overridden per-action)
  
  // Debug Logging (optional)
  debug: true,  // Enable console.debug logging for development
  
  // AutoUpdate Debounce (optional)
  autoUpdateDebounceDelay: 200,  // Debounce time in ms for rapid parameter changes (default: 100)
  
  // Request Interceptor (optional)
  requestInterceptor: async (url, requestInit) => {
    // Modify request before sending
    // Return modified RequestInit or null to abort
    return {
      ...requestInit,
      headers: {
        ...requestInit.headers,
        'X-Custom-Header': 'value'
      }
    }
  },
  
  // Response Interceptor (optional)
  responseInterceptor: async (response, url, requestInit) => {
    // Modify response or handle errors
    if (response.status === 401) {
      // Handle unauthorized
      throw new Error('Unauthorized')
    }
    return response
  },
  
  // Default Fetch Options (optional)
  fetchOptions: {
    credentials: 'include',
    mode: 'cors'
  }
})
```

### Setup Parameters

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Type</th>
      <th>Required</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>baseUrl</code></td>
      <td><code>string | Ref | ComputedRef</code></td>
      <td>Yes</td>
      <td>-</td>
      <td>Base URL for all API requests. Can be reactive.</td>
    </tr>
    <tr>
      <td><code>csrf</code></td>
      <td><code>CsrfOptions</code></td>
      <td>No</td>
      <td>-</td>
      <td>CSRF protection configuration</td>
    </tr>
    <tr>
      <td><code>csrf.enabled</code></td>
      <td><code>boolean</code></td>
      <td>No</td>
      <td><code>false</code></td>
      <td>Enable CSRF token injection</td>
    </tr>
    <tr>
      <td><code>csrf.cookieName</code></td>
      <td><code>string</code></td>
      <td>No</td>
      <td><code>'csrf_token'</code></td>
      <td>Cookie name containing CSRF token</td>
    </tr>
    <tr>
      <td><code>csrf.headerName</code></td>
      <td><code>string</code></td>
      <td>No</td>
      <td><code>'X-CSRF-Token'</code></td>
      <td>Header name to send CSRF token</td>
    </tr>
    <tr>
      <td><code>deduplication</code></td>
      <td><code>boolean</code></td>
      <td>No</td>
      <td><code>false</code></td>
      <td>Enable request deduplication globally (disabled by default)</td>
    </tr>
    <tr>
      <td><code>trailingSlash</code></td>
      <td><code>true | false | null</code></td>
      <td>No</td>
      <td>-</td>
      <td>Normalize path trailing slash: <code>true</code> = always add, <code>false</code> = always remove, <code>null</code>/omit = don't change. Overridable per-request via UseFzFetchOptions.trailingSlash.</td>
    </tr>
    <tr>
      <td><code>debug</code></td>
      <td><code>boolean</code></td>
      <td>No</td>
      <td><code>false</code></td>
      <td>Enable debug logging</td>
    </tr>
    <tr>
      <td><code>autoUpdateDebounceDelay</code></td>
      <td><code>number</code></td>
      <td>No</td>
      <td><code>100</code></td>
      <td>Debounce time in milliseconds for autoUpdate watches in list/paginated-list actions. Groups rapid parameter changes into a single fetch request.</td>
    </tr>
    <tr>
      <td><code>requestInterceptor</code></td>
      <td><code>RequestInterceptor</code></td>
      <td>No</td>
      <td>-</td>
      <td>Function to modify/abort requests</td>
    </tr>
    <tr>
      <td><code>responseInterceptor</code></td>
      <td><code>ResponseInterceptor</code></td>
      <td>No</td>
      <td>-</td>
      <td>Function to modify/handle responses</td>
    </tr>
    <tr>
      <td><code>fetchOptions</code></td>
      <td><code>RequestInit</code></td>
      <td>No</td>
      <td>-</td>
      <td>Default options for fetch requests</td>
    </tr>
  </tbody>
</table>

### Interceptors Examples

Interceptors allow you to modify requests before they're sent or handle responses globally. They're configured once in `setupFzFetcher` and apply to all requests.

**Request Interceptor - Add Custom Headers:**

```typescript
setupFzFetcher({
  baseUrl: 'https://api.example.com/v1',
  requestInterceptor: async (url, requestInit) => {
    const token = localStorage.getItem('auth_token')
    return {
      ...requestInit,
      headers: {
        ...requestInit.headers,
        'Authorization': `Bearer ${token}`
      }
    }
  }
})
```

**Request Interceptor - Abort Requests:**

```typescript
setupFzFetcher({
  baseUrl: 'https://api.example.com/v1',
  requestInterceptor: async (url, requestInit) => {
    // Abort if user is offline
    if (!navigator.onLine) {
      return null // Abort request
    }
    return requestInit
  }
})
```

**Response Interceptor - Handle 401 Errors:**

```typescript
setupFzFetcher({
  baseUrl: 'https://api.example.com/v1',
  responseInterceptor: async (response, url, requestInit) => {
    if (response.status === 401) {
      // Refresh token logic
      await refreshToken()
      // Retry original request
      return fetch(url, requestInit)
    }
    return response
  }
})
```

### Request Deduplication

Prevent duplicate identical requests. **Deduplication works globally across your entire application**. When multiple components make identical requests simultaneously, only the first one executes and others share the result.

**⚠️ Important:** Deduplication is **disabled by default**. You must explicitly enable it in `setupFzFetcher` or per-action.

**Global Behavior:**
- Single `DeduplicationManager` instance shared across all components
- Works between different components, different composables, and different parts of your app
- Only identical requests (same URL, query params, method, and body) are deduplicated
- Requests are automatically cleaned up after completion

**Example - Cross-Component Deduplication:**

```typescript
// ComponentA.vue
const { data: usersA } = useListUsers({ filters: { active: true } })
// Executes: GET /users?active=true

// ComponentB.vue (different component, same moment)
const { data: usersB } = useListUsers({ filters: { active: true } })
// ✅ Does NOT execute new request - shares result from ComponentA
// Both components receive the same data when the request completes
```

**Configuration:**

```typescript
// Global setting (disabled by default)
setupFzFetcher({
  baseUrl: 'https://api.example.com/v1',
  deduplication: true // ✅ Must be explicitly enabled
})

// Per-action override
const { data } = useListUsers(
  { filters: { enabled: true } },
  { deduplication: true } // Enable for this action (overrides global)
)
```

---

## API Quick Reference

Use this section as a **cheat sheet**: all actions, call-with-defaults helpers, and useFzFetch in one place — params, options, return values, and how to call `execute` for mutations. For details and examples, see [Usage Pattern](#usage-pattern), [Custom Actions & Merge Helpers](#custom-actions--merge-helpers), and [Actions Reference](#actions-reference).

### Actions from useActions (CRUD)

Obtain actions from `useActions<T>(basePath)` (e.g. `const { useRetrieve, useList, usePaginatedList, useCreate, useUpdate, useDelete } = useActions<User>('users')`).

<table>
  <thead>
    <tr>
      <th>Action</th>
      <th>Call</th>
      <th>Params / Options</th>
      <th>Returns</th>
      <th>execute / usage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>useRetrieve</strong></td>
      <td><code>useRetrieve(pk?, options?)</code></td>
      <td><code>pk</code>: string | number | Ref | ComputedRef (required). <code>options</code>: onMount?, autoUpdate?, initialData?, deduplication?, throwOnError?</td>
      <td><code>data</code>, <code>error</code>, <code>isLoading</code>, <code>execute</code></td>
      <td>Query: auto on mount. Manual: <code>await execute(throwOnError?)</code></td>
    </tr>
    <tr>
      <td><strong>useList</strong></td>
      <td><code>useList()</code> / <code>useList(params?, options?)</code></td>
      <td><code>params</code>: filters?, ordering?, pagination? (initial; then use returned reactive objects). <code>options</code>: onMount?, autoUpdate?, initialData?, deduplication?, throwOnError?</td>
      <td><code>data</code>, <code>error</code>, <code>isLoading</code>, <code>execute</code>, <code>filters</code>, <code>ordering</code>, <code>pagination</code> (reactive)</td>
      <td>Query: auto on mount; change filters/ordering/pagination to refetch. Manual: <code>await execute(throwOnError?)</code></td>
    </tr>
    <tr>
      <td><strong>usePaginatedList</strong></td>
      <td><code>usePaginatedList()</code> / <code>usePaginatedList(params?, options?)</code></td>
      <td>Same params as useList. <code>options</code>: + dataKey?, enableSingleOrdering?, and query options</td>
      <td>Like useList + <code>meta</code>, <code>handlePageChange(page)</code>, <code>handleOrderingChange(column, direction)</code></td>
      <td>Same as useList; pagination always applied (default page 1, pageSize 50)</td>
    </tr>
    <tr>
      <td><strong>useCreate</strong></td>
      <td><code>useCreate(options?)</code></td>
      <td><code>options</code>: throwOnError?</td>
      <td><code>data</code>, <code>error</code>, <code>isLoading</code>, <code>execute</code></td>
      <td><code>await execute(payload)</code> — payload = partial entity object (e.g. createUser with name, email)</td>
    </tr>
    <tr>
      <td><strong>useUpdate</strong></td>
      <td><code>useUpdate(options?)</code></td>
      <td><code>options</code>: throwOnError?</td>
      <td><code>data</code>, <code>error</code>, <code>isLoading</code>, <code>execute</code></td>
      <td><code>await execute(pk, payload, opts)</code> — opts.partialUpdate = true (PATCH) or false (PUT). E.g. updateUser(1, payload)</td>
    </tr>
    <tr>
      <td><strong>useDelete</strong></td>
      <td><code>useDelete(options?)</code></td>
      <td><code>options</code>: throwOnError?</td>
      <td><code>data</code>, <code>error</code>, <code>isLoading</code>, <code>execute</code></td>
      <td><code>await execute(pk)</code> — e.g. <code>await deleteUser(1)</code></td>
    </tr>
  </tbody>
</table>

**Query options (useRetrieve, useList, usePaginatedList):** `onMount` (default true), `autoUpdate` (default true), `initialData`, `deduplication`, `throwOnError` (default false). **Mutation options:** only `throwOnError` (default false).

**List params:** `filters` = key/value (undefined = omit, null = send); `ordering` = e.g. `[{ name: 'asc' }, { created_at: 'desc' }]`; `pagination` = `{ page?, pageSize? }`. If you pass `pagination` (even `{}`), useList applies page 1, pageSize 50 by default.

---

### Call-with-defaults helpers

Use when building **custom actions** that preconfigure defaults but let the view override or add params/options. Each helper **calls** the underlying action with merged args.

<table>
  <thead>
    <tr>
      <th>Helper</th>
      <th>Action</th>
      <th>Input</th>
      <th>Note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>callListActionWithDefaults</code></td>
      <td>useList</td>
      <td>defaultParams?, defaultOptions?, additionalParamsOrOptions?, additionalOptions?</td>
      <td>Pagination in request only if you pass pagination in defaultParams or view params</td>
    </tr>
    <tr>
      <td><code>callPaginatedListActionWithDefaults</code></td>
      <td>usePaginatedList</td>
      <td>defaultParams?, defaultOptions?, additionalParamsOrOptions?, additionalOptions?</td>
      <td>Pagination always in params (default page/pageSize applied)</td>
    </tr>
    <tr>
      <td><code>callRetrieveActionWithDefaults</code></td>
      <td>useRetrieve</td>
      <td>defaultPk?, defaultOptions?, overridePk?, additionalOptions?</td>
      <td>overridePk wins over defaultPk; at least one of defaultPk or overridePk needed</td>
    </tr>
    <tr>
      <td><code>callCreateActionWithDefaults</code></td>
      <td>useCreate</td>
      <td>defaultOptions?, additionalOptions?</td>
      <td>Returns action(mergedOptions)</td>
    </tr>
    <tr>
      <td><code>callUpdateActionWithDefaults</code></td>
      <td>useUpdate</td>
      <td>defaultOptions?, additionalOptions?</td>
      <td>Returns action(mergedOptions)</td>
    </tr>
    <tr>
      <td><code>callDeleteActionWithDefaults</code></td>
      <td>useDelete</td>
      <td>defaultOptions?, additionalOptions?</td>
      <td>Returns action(mergedOptions)</td>
    </tr>
  </tbody>
</table>

**Example:** custom list with default filters, view can override:

```typescript
const useInvoicesList = (paramsOrOptions?, options?) =>
  callListActionWithDefaults(useList, {
    defaultParams: { filters: { status: 'active' } },
    additionalParamsOrOptions: paramsOrOptions,
    additionalOptions: options,
  })
// In view: useInvoicesList({ filters: { status: 'paid' }, pagination: { page: 2 } })
```

---

### useFzFetch (low-level)

Use for **custom or nested routes** (URL not from useActions), or when you need a reactive URL/body/headers. Supports GET and mutations (POST/PUT/PATCH/DELETE); CSRF and interceptors apply.

**Signatures:**

```typescript
useFzFetch<T>(url: MaybeRefOrGetter<string>): UseFzFetchReturn<T>
useFzFetch<T>(url, options?: UseFzFetchOptions): UseFzFetchReturn<T>
useFzFetch<T>(url, params: { queryParams?, method?, body?, headers? }, options?: UseFzFetchOptions): UseFzFetchReturn<T>
```

**Returns:** `data`, `error`, `statusCode`, `response`, `isFetching`, `execute(throwOnFailed?)`.

**Options:** `immediate` (default true), `refetch`, `initialData`, `deduplication`, `trailingSlash` (overrides setup).

**Examples:**

```typescript
// GET – reactive URL
const userId = ref(1)
const { data } = useFzFetch<User>(computed(() => `/users/${userId.value}`))

// GET with query params
const { data } = useFzFetch<User[]>('/users', { queryParams: { role: 'admin' } })

// POST – body/headers evaluated at execute time
const { execute } = useFzFetch<User>('/users', {
  method: 'POST',
  body: computed(() => JSON.stringify(payload.value)),
  headers: { 'Content-Type': 'application/json' },
}, { immediate: false })
await execute()
```

When the URL depends on another resource (e.g. `/users/1/stats`), build the URL with `computed()` and pass it to `useFzFetch`. For one-off mutations (e.g. mark as paid), pass body/headers at call time and use `immediate: false` then `execute()`.

---

## Usage Pattern

### Step 1: Create Entity Composable

Create a composable for each entity type (e.g., `useUsers`, `useInvoices`, `useCreditNotes`).

```typescript
// src/composables/useUsers.ts
import { useActions } from '@fiscozen/data/rest'

interface User {
  id: number
  name: string
  email: string
  enabled: boolean
}

export const useUsers = () => {
  const { useRetrieve, useList, useCreate, useUpdate, useDelete } = 
    useActions<User>('users')
  
  return {
    // Query actions (GET)
    useRetrieveUserById: useRetrieve,
    useListUsers: useList,
    
    // Mutation actions (POST/PUT/PATCH/DELETE)
    useCreateUser: useCreate,
    useUpdateUser: useUpdate,
    useDeleteUser: useDelete
  }
}
```

### Step 2: Use in Components

```vue
<script setup lang="ts">
import { ref } from 'vue'
import { useUsers } from '@/composables/useUsers'

const { useListUsers, useCreateUser } = useUsers()

// Query: Auto-fetches on mount, auto-refetches when filters change
const filters = ref({ enabled: true })
const { data: users, error: listError, isLoading: isLoadingList } = useListUsers({
  filters // Reactive - changes trigger automatic refetch
})

// Mutation: Always manual
const { 
  data: createdUser, 
  error: createError, 
  isLoading: isCreating, 
  execute: createUser 
} = useCreateUser()

const name = ref('')
const email = ref('')

const handleCreate = async () => {
  await createUser({ 
    name: name.value, 
    email: email.value 
  })
}
</script>

<template>
  <div>
    <!-- Query Loading/Error States -->
    <div v-if="isLoadingList">Loading users...</div>
    <div v-else-if="listError">Error loading users: {{ listError.message }}</div>
    <ul v-else>
      <li v-for="user in users" :key="user.id">{{ user.name }}</li>
    </ul>

    <!-- Create User Form -->
    <form @submit.prevent="handleCreate">
      <input v-model="name" placeholder="Name" required />
      <input v-model="email" placeholder="Email" type="email" required />
      
      <button type="submit" :disabled="isCreating">
        {{ isCreating ? 'Creating...' : 'Create User' }}
      </button>
      
      <!-- Mutation Error State -->
      <div v-if="createError" class="error">
        Error creating user: {{ createError.message }}
      </div>
      
      <!-- Mutation Success State -->
      <div v-if="createdUser" class="success">
        User created: {{ createdUser.name }} (ID: {{ createdUser.id }})
      </div>
    </form>
  </div>
</template>
```

---

## Custom Actions & Merge Helpers

When you need **preconfigured actions** (e.g. a list with fixed filters) but still want the view to override or add params/options, use the **call-with-defaults helpers**. Each helper **calls** the action with **default args** merged with **additional args** from the view — so the composable body is just `return callXActionWithDefaults(actionBase, { defaultParams, defaultOptions, additionalParamsOrOptions, additionalOptions })`. Entity type inferred from the action; no generic to specify. All input fields accept `MaybeRefOrGetter` for reactive defaults.

**Import:** `import { callListActionWithDefaults, callPaginatedListActionWithDefaults, callRetrieveActionWithDefaults, callCreateActionWithDefaults, callUpdateActionWithDefaults, callDeleteActionWithDefaults } from '@fiscozen/data/rest'` (or `from '@fiscozen/data'`).

### Call-with-defaults helpers — one per action type

<table>
  <thead>
    <tr>
      <th>Helper</th>
      <th>Action</th>
      <th>Input shape</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>callListActionWithDefaults</code></td>
      <td>useList</td>
      <td>defaultParams?, defaultOptions?, additionalParamsOrOptions?, additionalOptions?</td>
    </tr>
    <tr>
      <td><code>callPaginatedListActionWithDefaults</code></td>
      <td>usePaginatedList</td>
      <td>defaultParams?, defaultOptions?, additionalParamsOrOptions?, additionalOptions?</td>
    </tr>
    <tr>
      <td><code>callRetrieveActionWithDefaults</code></td>
      <td>useRetrieve</td>
      <td>defaultPk?, defaultOptions?, overridePk?, additionalOptions?</td>
    </tr>
    <tr>
      <td><code>callCreateActionWithDefaults</code></td>
      <td>useCreate</td>
      <td>defaultOptions?, additionalOptions?</td>
    </tr>
    <tr>
      <td><code>callUpdateActionWithDefaults</code></td>
      <td>useUpdate</td>
      <td>defaultOptions?, additionalOptions?</td>
    </tr>
    <tr>
      <td><code>callDeleteActionWithDefaults</code></td>
      <td>useDelete</td>
      <td>defaultOptions?, additionalOptions?</td>
    </tr>
  </tbody>
</table>

**List / Paginated list:** Merge semantics: filters and pagination merged (view wins); ordering: view wins if provided; options: view wins. **Pagination in the request:** For `callListActionWithDefaults` (useList), `page` and `page_size` are only sent when you explicitly pass `pagination` in `defaultParams` or the view passes it in params — so list requests do not get pagination by default. For `callPaginatedListActionWithDefaults` (usePaginatedList), pagination is always included in the merged params so the action can apply default page/pageSize when not specified.

**Retrieve:** At least one of `defaultPk` or `overridePk` when calling the underlying action.

**Filter value semantics (list/paginated):** `undefined` = omit from request; `null` = send to the server.

**Example – custom actions with default parameters:**

```typescript
// e.g. src/composables/useInvoices.ts
import { ref } from 'vue'
import {
  useActions,
  callListActionWithDefaults,
  callPaginatedListActionWithDefaults,
  callRetrieveActionWithDefaults,
  callCreateActionWithDefaults,
  callUpdateActionWithDefaults,
  callDeleteActionWithDefaults,
} from '@fiscozen/data'

interface Invoice {
  id: number
  name: string
  status: string
  created_at: string
}

export const useInvoices = () => {
  const {
    useList,
    usePaginatedList,
    useRetrieve,
    useCreate,
    useUpdate,
    useDelete,
  } = useActions<Invoice>('invoices/')

  const useInvoicesList = (paramsOrOptions?, options?) =>
    callListActionWithDefaults(useList, {
      defaultParams: {
        filters: { sts: true, sts_sent: false, sts_summary: '' },
      },
      additionalParamsOrOptions: paramsOrOptions,
      additionalOptions: options,
    })

  const useInvoicesPaginatedList = (paramsOrOptions?, options?) =>
    callPaginatedListActionWithDefaults(usePaginatedList, {
      defaultParams: {
        filters: { status: 'active' },
        pagination: { page: 1, pageSize: 20 },
      },
      defaultOptions: { dataKey: 'results', enableSingleOrdering: false },
      additionalParamsOrOptions: paramsOrOptions,
      additionalOptions: options,
    })

  const useRetrieveInvoice = (pk?, options?) =>
    callRetrieveActionWithDefaults(useRetrieve, {
      defaultPk: 68,
      overridePk: pk,
      additionalOptions: options,
    })

  const useCreateInvoice = (options?) =>
    callCreateActionWithDefaults(useCreate, {
      defaultOptions: { throwOnError: true },
      additionalOptions: options,
    })

  const useUpdateInvoice = (options?) =>
    callUpdateActionWithDefaults(useUpdate, {
      defaultOptions: {},
      additionalOptions: options,
    })

  const useDeleteInvoice = (options?) =>
    callDeleteActionWithDefaults(useDelete, {
      defaultOptions: {},
      additionalOptions: options,
    })

  return {
    useInvoicesList,
    useInvoicesPaginatedList,
    useRetrieveInvoice,
    useCreateInvoice,
    useUpdateInvoice,
    useDeleteInvoice,
  }
}
```

**In the view:** Call `useInvoices()` once, then use the returned actions. Same API as the base actions; you can override or add params/options.

```vue
<script setup>
import { useInvoices } from '@/composables/useInvoices'

const { useInvoicesList, useInvoicesPaginatedList } = useInvoices()

const { data, filters, pagination, ordering } = useInvoicesList(
  { pagination: { page: 1, pageSize: 20 }, ordering: [{ created_at: 'desc' }] },
  { onMount: true, autoUpdate: true }
)

const { data: paginatedData, meta, handlePageChange } = useInvoicesPaginatedList(
  { pagination: { page: 2 } },
  { autoUpdate: true }
)
</script>
```

---

## Nested and custom routes

For endpoints that don't fit the standard CRUD pattern, use **useFzFetch** directly in your entity composables. This **hybrid approach** combines **useActions** for standard CRUD operations with **useFzFetch** for custom endpoints.

**Why hybrid?** `useActions(basePath)` accepts a **string** base path only, so you cannot pass a reactive path or a path that depends on call-time values. `useFzFetch(basePath, ...)` accepts a reactive or static URL (`MaybeRefOrGetter<string>`), so you use it inside a thin composable that builds the URL with `computed()`. **Body and headers** also support `MaybeRefOrGetter` and are re-evaluated on each `execute()`, so you can pass a ref or computed for the payload and have the request use the current value when the user triggers the action. CSRF, interceptors, and deduplication still apply.

**Two patterns:**

- **List and retrieve (GET):** Pass a **ref** (or params) to the composable at setup. The URL is built from that ref with `computed()`; when the ref changes, the request refetches. Same idea as `useRetrieve(pk)` or `useList({ filters })` where you pass the key/list params at setup and they are reactive. Examples: nested resource (e.g. user stats by `userId`), custom GET (e.g. export by `invoiceIds`).
- **Mutations (POST/PUT/PATCH/DELETE):** Pass the values to **execute()** at call time, like **useUpdate** which takes `execute(pk, payload)`. The composable keeps a ref inside, builds the URL with `computed()`, uses `useFzFetch(..., { immediate: false })`, and exposes an `execute(id)` (or `execute(pk, payload)`) that sets the ref and runs the fetch. The view does not hold a ref for the target id; it calls `execute(invoice.id)` when the user acts.

### When to use useFzFetch directly

Use **useFzFetch** directly when you need:

- **Nested or custom GET** – List/retrieve whose path or query depends on a ref (e.g. `users/{userId}/stats`, export by ids); pass the ref at setup.
- **Custom mutations** – POST/PUT/PATCH/DELETE whose path or body depends on call-time values (e.g. `invoices/{id}/mark_as_paid`); pass values to `execute()`.


### Example 1: Nested resource – user stats (GET, ref at setup)

**Scenario:** Fetch user statistics from `GET /users/{userId}/stats`.

**Implementation:**

```typescript
// src/composables/useUsers.ts
import { useActions, useFzFetch } from '@fiscozen/data/rest'
import { computed, toValue } from 'vue'
import type { MaybeRefOrGetter } from 'vue'

interface UserStats {
  totalOrders: number
  revenue: number
  activeSubscriptions: number
  lastActivityDate: string
}

export const useUsers = () => {
  const { useRetrieve, useList, useCreate, useUpdate, useDelete } =
    useActions<User>('users/')

  const useGetUserStats = (userId: MaybeRefOrGetter<number>) => {
    const url = computed(() => `users/${toValue(userId)}/stats/`)
    const result = useFzFetch<UserStats>(url)
    return { ...result, isLoading: result.isFetching }
  }

  return {
    useRetrieveUserById: useRetrieve,
    useListUsers: useList,
    useCreateUser: useCreate,
    useUpdateUser: useUpdate,
    useDeleteUser: useDelete,
    useGetUserStats
  }
}
```

**Usage in component:**

```vue
<script setup lang="ts">
import { ref } from 'vue'
import { useUsers } from '@/composables/useUsers'

const { useGetUserStats } = useUsers()

const userId = ref(68)
const { data: stats, error, isLoading } = useGetUserStats(userId)

const loadStatsForUser = (id: number) => {
  userId.value = id
}
</script>
```

**Key points:** GET pattern – pass `userId` (ref or getter) at setup; the URL is reactive and refetches when `userId` changes. Same idea as passing a ref to a list/retrieve composable.

### Example 2: Custom endpoint with query string – export invoices (GET, ref at setup)

**Scenario:** Export invoices as file from `GET /esporta/lista_fatture/{invoiceIds}/?zip`.

**Implementation:**

```typescript
// src/composables/useInvoices.ts
import { useActions, useFzFetch } from '@fiscozen/data/rest'
import { computed, toValue } from 'vue'
import type { MaybeRefOrGetter } from 'vue'

export const useInvoices = () => {
  const { useRetrieve, useList, useCreate, useUpdate, useDelete } =
    useActions<Invoice>('invoices')

  const useExportInvoices = (
    invoiceIds: MaybeRefOrGetter<number[]>,
    format: 'zip' | 'pdf' = 'zip'
  ) => {
    const url = computed(() => {
      const ids = toValue(invoiceIds)
      if (!ids || ids.length === 0) {
        throw new Error('At least one invoice ID is required for export')
      }
      return `esporta/lista_fatture/${ids.join('-')}`
    })
    const result = useFzFetch<Blob>(url, {
      queryParams: { [format]: true }
    })
    return { ...result, isLoading: result.isFetching }
  }

  return {
    useRetrieveInvoiceById: useRetrieve,
    useListInvoices: useList,
    useCreateInvoice: useCreate,
    useUpdateInvoice: useUpdate,
    useDeleteInvoice: useDelete,
    useExportInvoices
  }
}
```

**Usage in component:**

```vue
<script setup lang="ts">
import { ref } from 'vue'
import { useInvoices } from '@/composables/useInvoices'

const { useExportInvoices } = useInvoices()

const selectedInvoiceIds = ref<number[]>([1, 2, 3])
const { data: fileBlob, error, isLoading: isExporting, execute: exportInvoices } =
  useExportInvoices(selectedInvoiceIds, 'zip')

const handleExport = async () => {
  if (selectedInvoiceIds.value.length === 0) return
  await exportInvoices()
  if (fileBlob.value) {
    // Create download link, trigger download, cleanup
  }
}
</script>
```

**Key points:** GET pattern – pass `invoiceIds` and `format` at setup; URL and query params are reactive; call `execute()` to run the request (e.g. on button click). Handle blob response for file downloads.

### Example 3: Custom mutation – mark invoice as paid (POST, values at execute)

**Scenario:** Mark a single invoice as paid with `POST /invoices/{invoiceId}/mark_as_paid/`. The invoice id is known when the user triggers the action (e.g. click on a row), not at setup.

**Implementation:**

```typescript
// src/composables/useInvoices.ts
import { useActions, useFzFetch } from '@fiscozen/data/rest'
import { computed, ref } from 'vue'

export const useInvoices = () => {
  const { useRetrieve, useList, useCreate, useUpdate, useDelete } =
    useActions<Invoice>('invoices')

  const useMarkAsPaid = (options?: { throwOnError?: boolean }) => {
    const invoiceIdRef = ref<number | null>(null)
    const url = computed(() => `invoices/${invoiceIdRef.value ?? 0}/mark_as_paid/`)
    const fetchResult = useFzFetch<unknown>(
      url,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: null,
      },
      { immediate: false },
    )

    const execute = async (invoiceId: number) => {
      invoiceIdRef.value = invoiceId
      await fetchResult.execute(options?.throwOnError ?? false)
    }

    return { ...fetchResult, execute, isLoading: fetchResult.isFetching }
  }

  return {
    useRetrieveInvoiceById: useRetrieve,
    useListInvoices: useList,
    useCreateInvoice: useCreate,
    useUpdateInvoice: useUpdate,
    useDeleteInvoice: useDelete,
    useMarkAsPaid
  }
}
```

**Usage in component:**

```vue
<script setup lang="ts">
import { useInvoices } from '@/composables/useInvoices'

const { useMarkAsPaid } = useInvoices()
const { execute: performMarkAsPaid } = useMarkAsPaid({ throwOnError: true })

const handleMarkAsPaid = async (invoice: { id: number }) => {
  await performMarkAsPaid(invoice.id)
}
</script>
```

**Key points:** Mutation pattern – like **useUpdate** which takes `execute(pk, payload)`. Pass the id (or pk and payload) to `execute()` at call time; no ref in the view for the target id. Use `immediate: false` and a ref inside the composable so the URL is set when `execute(id)` runs.

**Reactive body/headers:** If the mutation body or headers depend on form state or other reactive data, pass a ref or computed for `body` and/or `headers`. They are re-evaluated on each `execute()`, so the request always uses the current value. Example below: composable with reactive payload and usage that calls `execute()` twice with different payloads.

**Example: Mark invoice as paid with payment details (reactive body)**

**Scenario:** `POST /invoices/{invoiceId}/mark_as_paid/` with a body that includes payment date and method. The payload comes from form state and can change before each submit; the same composable instance sends the current payload on each `execute()`.

**Implementation:**

```typescript
// src/composables/useInvoices.ts
import { useActions, useFzFetch } from '@fiscozen/data/rest'
import { computed, ref } from 'vue'

export const useInvoices = () => {
  const { useRetrieve, useList, useCreate, useUpdate, useDelete } =
    useActions<Invoice>('invoices')

  const useMarkInvoiceAsPaid = (options?: { throwOnError?: boolean }) => {
    const invoiceIdRef = ref<number | null>(null)
    const payload = ref<{ payment_date: string | null; payment_method: string | null }>({
      payment_date: null,
      payment_method: null,
    })
    const url = computed(() => `invoices/${invoiceIdRef.value ?? 0}/mark_as_paid/`)
    const fetchResult = useFzFetch<unknown>(url, {
      method: 'POST',
      body: computed(() => JSON.stringify(payload.value)),
      headers: { 'Content-Type': 'application/json' },
    }, { immediate: false })

    const execute = async ({invoiceId, paymentDate, paymentMethod}: {invoiceId: number, paymentDate: string, paymentMethod: string}) => {
      invoiceIdRef.value = invoiceId
      payload.value = {
        payment_date: paymentDate,
        payment_method: paymentMethod,
      }
      await fetchResult.execute(options?.throwOnError ?? false)
    }

    return { ...fetchResult, execute, isLoading: fetchResult.isFetching }
  }

  return {
    useRetrieveInvoiceById: useRetrieve,
    useListInvoices: useList,
    useCreateInvoice: useCreate,
    useUpdateInvoice: useUpdate,
    useDeleteInvoice: useDelete,
    useMarkInvoiceAsPaid
  }
}
```

**Usage in component:**

```vue
<script setup lang="ts">
import { useInvoices } from '@/composables/useInvoices'

const { useMarkInvoiceAsPaid } = useInvoices()
const { execute: markAsPaid, data, error, isLoading } = useMarkInvoiceAsPaid({ throwOnError: true })

const handleMarkAsPaid = async (invoice: { id: number }) => {
  await markAsPaid({
    invoiceId: invoice.id,
    paymentDate: '2025-01-01',
    paymentMethod: 'card',
  })
}
</script>
```

**Key points:** Same pattern as **Example 3** (mark as paid): URL from ref, `execute(...)` at call time. Here the **body** is reactive: `body: computed(() => JSON.stringify(payload.value))` so each `execute()` sends the current `payload`. The view passes all data to `execute({ invoiceId, paymentDate, paymentMethod })`; the composable sets refs and runs the fetch, so no need to build the request inside `execute()`.

### When to use which

<table>
  <thead>
    <tr>
      <th>Use case</th>
      <th>Approach</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Standard CRUD, fixed base path (e.g. users, invoices)</td>
      <td><strong>useActions</strong> and entity composable (e.g. useUsers, useInvoices)</td>
    </tr>
    <tr>
      <td><strong>Nested or custom GET</strong> (list/retrieve with id or params in path/query)</td>
      <td>Composable with <strong>useFzFetch</strong> and computed URL; pass ref at setup (e.g. useGetUserStats(userId), useExportInvoices(invoiceIds, format)). URL refetches when ref changes.</td>
    </tr>
    <tr>
      <td><strong>Custom mutations</strong> (POST/PUT/PATCH/DELETE with id in path or call-time params)</td>
      <td>Composable with <strong>useFzFetch</strong> (immediate: false) and execute(id) or execute(pk, payload); pass values at call time (like useUpdate execute(pk, payload)).</td>
    </tr>
    <tr>
      <td>Preconfigured list/retrieve with default params but same URL shape</td>
      <td>Merge helpers + useActions (see Custom Actions &amp; Merge Helpers)</td>
    </tr>
  </tbody>
</table>

Consumers get a consistent API: composables return `data` / `error` / `isLoading` / `execute`. For GET you pass the ref (or params) at setup; for mutations you pass the values to `execute()` when the user acts.

---

## Actions Reference

### Query Actions (GET)

Query actions automatically fetch data on mount and refetch when reactive parameters change.

#### `useRetrieve` - Get Single Entity

Retrieves a single entity by its primary key.

**Signature:**
```typescript
useRetrieve(
  pk?: string | number | Ref<string | number> | ComputedRef<string | number>,
  options?: UseRetrieveActionOptions<T>
): UseRetrieveActionReturn<T>
```

**Parameters:**

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Type</th>
      <th>Required</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>pk</code></td>
      <td><code>string | number | Ref | ComputedRef</code></td>
      <td>Yes</td>
      <td>Primary key of the entity. Can be reactive - changes trigger refetch.</td>
    </tr>
    <tr>
      <td><code>options</code></td>
      <td><code>UseRetrieveActionOptions&lt;T&gt;</code></td>
      <td>No</td>
      <td>Query options (see below)</td>
    </tr>
  </tbody>
</table>

**Returns:**

```typescript
{
  data: ShallowRef<T | null>,      // Response data
  error: ShallowRef<Error | null>, // Error if request failed
  isLoading: Readonly<ShallowRef<boolean>>, // Loading state
  execute: () => Promise<void>     // Manual execute function
}
```

**Example:**

```vue
<script setup>
import { ref } from 'vue'
import { useUsers } from '@/composables/useUsers'

const { useRetrieveUserById } = useUsers()

// Reactive ID - auto-refetches when userId changes
const userId = ref(1)
const { data: user, error, isLoading } = useRetrieveUserById(userId)

// Change ID to load different user
userId.value = 2 // ✅ Automatically refetches
</script>
```

#### `useList` - List Entities

Lists entities with optional filters, ordering, and pagination.

**Signature:**
```typescript
useList(): UseListActionReturn<T>
useList(params: UseListActionParams): UseListActionReturn<T>
useList(options: UseListActionOptions<T>): UseListActionReturn<T>
useList(params: UseListActionParams, options: UseListActionOptions<T>): UseListActionReturn<T>
```

**Parameters:**

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Type</th>
      <th>Required</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>params</code></td>
      <td><code>UseListActionParams</code></td>
      <td>No</td>
      <td>Query parameters (see below)</td>
    </tr>
    <tr>
      <td><code>options</code></td>
      <td><code>UseListActionOptions&lt;T&gt;</code></td>
      <td>No</td>
      <td>Query options (see below)</td>
    </tr>
  </tbody>
</table>

**UseListActionParams:**

Initial parameters (used only for bootstrap). The composable returns reactive objects that can be modified directly.

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Type</th>
      <th>Required</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>filters</code></td>
      <td><code>Record | Ref | ComputedRef</code></td>
      <td>No</td>
      <td>Initial filter parameters. Query semantics: undefined = omit from request; null = send to server. After initialization, modify the returned filters reactive object directly.</td>
    </tr>
    <tr>
      <td><code>ordering</code></td>
      <td><code>Array | Ref | ComputedRef</code></td>
      <td>No</td>
      <td>Initial ordering parameters as array of objects (e.g. name: asc, created_at: desc). Normalized to query string format: ordering=name,-created_at. After initialization, modify the returned ordering reactive array directly.</td>
    </tr>
    <tr>
      <td><code>pagination</code></td>
      <td><code>object (page?, pageSize?) | Ref | ComputedRef</code></td>
      <td>No</td>
      <td>Initial pagination parameters. If provided (even if empty), default values are applied: page defaults to 1, pageSize defaults to 50. After initialization, modify the returned pagination reactive object directly.</td>
    </tr>
  </tbody>
</table>

**Returns:**

```typescript
{
  data: ShallowRef<T[] | null>,    // Array of entities
  error: ShallowRef<Error | null>, // Error if request failed
  isLoading: Readonly<ShallowRef<boolean>>, // Loading state
  execute: () => Promise<void>,    // Manual execute function
  filters: Reactive<Record<...>>,  // Reactive filters - modify directly
  ordering: Reactive<Array<Record<...>>>, // Reactive ordering - modify directly
  pagination: Reactive<{ page?: number, pageSize?: number }> // Reactive pagination - modify directly
}
```

**Example:**

```vue
<script setup>
import { useUsers } from '@/composables/useUsers'

const { useListUsers } = useUsers()

// useList returns reactive objects for direct modification
const { data: users, isLoading, filters, pagination, ordering } = useListUsers({
  filters: { enabled: true },           // Initial filters (static)
  pagination: { page: 1, pageSize: 20 }, // Initial pagination (static)
  // Note: If pagination is provided (even if empty), defaults are applied:
  // - page defaults to 1 if not specified
  // - pageSize defaults to 50 if not specified
  ordering: [{ name: 'asc' }]              // Initial ordering (static)
})

// Pagination defaults example
const { pagination: defaultPagination } = useListUsers({ pagination: {} })
// → defaultPagination = { page: 1, pageSize: 50 }

// Modify reactive objects directly - triggers auto-refetch (if autoUpdate: true)
filters.enabled = false        // ✅ Auto-refetches
filters.name = 'John'          // ✅ Auto-refetches
pagination.page = 2            // ✅ Auto-refetches
ordering.push({ created_at: 'desc' }) // ✅ Auto-refetches
</script>
```

**Reactive Parameters Best Practices:**

The `useList` action returns reactive objects (`filters`, `ordering`, `pagination`) that can be modified directly to trigger automatic refetches.

**✅ Recommended: Modify reactive objects directly**

```typescript
const { filters, pagination, ordering } = useListUsers({
  filters: { enabled: true },
  pagination: { page: 1, pageSize: 20 },
  ordering: [{ name: 'asc' }]
})

// ✅ Modify reactive objects directly - triggers auto-refetch (if autoUpdate: true)
filters.enabled = false        // ✅ Auto-refetches
filters.name = 'John'          // ✅ Auto-refetches
pagination.page = 2            // ✅ Auto-refetches
ordering.push({ created_at: 'desc' }) // ✅ Auto-refetches
```

**✅ Initial values are only for bootstrap**

```typescript
// Initial values (static) - used only once at initialization
const { filters, pagination, ordering } = useListUsers({
  filters: { enabled: true },           // Static initial value
  pagination: { page: 1, pageSize: 20 }, // Static initial value
  ordering: [{ name: 'asc' }]               // Static initial value
})

// After initialization, modify the returned reactive objects directly
filters.enabled = false // ✅ This triggers refetch, not the initial value
```

#### `usePaginatedList` - List Entities with Paginated Response

Lists entities with paginated response format and metadata extraction. Works exactly like `useList` but handles paginated responses with metadata.

**Signature:**
```typescript
usePaginatedList(): UsePaginatedListActionReturn<T>
usePaginatedList(params: UsePaginatedListActionParams): UsePaginatedListActionReturn<T>
usePaginatedList(options: UsePaginatedListActionOptions<T>): UsePaginatedListActionReturn<T>
usePaginatedList(params: UsePaginatedListActionParams, options: UsePaginatedListActionOptions<T>): UsePaginatedListActionReturn<T>
```

**Response Format:**
Expects API to return:
```typescript
{
  results: T[],           // Array of entities (or custom key via dataKey option)
  count: number,         // Total number of items across all pages
  next: string | null,   // URL to next page (if available)
  previous: string | null, // URL to previous page (if available)
  pages: number,         // Total number of pages
  page: number          // Current page number (1-indexed)
}
```

**Parameters:**

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Type</th>
      <th>Required</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>params</code></td>
      <td><code>UsePaginatedListActionParams</code></td>
      <td>No</td>
      <td>Same as UseListActionParams (filters, ordering, pagination)</td>
    </tr>
    <tr>
      <td><code>options</code></td>
      <td><code>UsePaginatedListActionOptions&lt;T&gt;</code></td>
      <td>No</td>
      <td>Options including dataKey and enableSingleOrdering</td>
    </tr>
  </tbody>
</table>

**UsePaginatedListActionOptions:**

<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>Type</th>
      <th>Required</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dataKey</code></td>
      <td><code>string</code></td>
      <td>No</td>
      <td><code>'results'</code></td>
      <td>Key name in paginated response that contains the data array</td>
    </tr>
    <tr>
      <td><code>enableSingleOrdering</code></td>
      <td><code>boolean</code></td>
      <td>No</td>
      <td><code>false</code></td>
      <td>When true, only one column can be ordered at a time</td>
    </tr>
  </tbody>
</table>

**Returns:**

```typescript
{
  data: ShallowRef<T[] | null>,        // Array of entities (extracted from results)
  error: ShallowRef<Error | null>,      // Error if request failed
  isLoading: Readonly<ShallowRef<boolean>>, // Loading state
  execute: () => Promise<void>,        // Manual execute function
  meta: ComputedRef<PaginationMeta | null>, // Pagination metadata
  filters: Reactive<Record<...>>,     // Reactive filters - modify directly
  ordering: Reactive<Array<Record<...>>>, // Reactive ordering - modify directly
  pagination: Reactive<PaginationParams>, // Reactive pagination - modify directly
  handlePageChange: (page: number) => void, // Helper to change page
  handleOrderingChange: (column: { field: string }, direction: 'asc' | 'desc' | 'none') => void // Helper to change ordering
}
```

**PaginationMeta:**

```typescript
interface PaginationMeta {
  count: number;    // Total number of items across all pages
  pages: number;    // Total number of pages
  page: number;    // Current page number (1-indexed, from API response)
}
```

**Example:**

```vue
<script setup>
import { useUsers } from '@/composables/useUsers'

const { usePaginatedListUsers } = useUsers()

// usePaginatedList returns reactive objects + meta
const { 
  data: users, 
  meta, 
  filters, 
  pagination, 
  ordering,
  handlePageChange,
  handleOrderingChange 
} = usePaginatedListUsers({
  filters: { active: true },
  pagination: { page: 1, pageSize: 20 },
  ordering: [{ name: 'asc' }]
})

// Access pagination metadata
console.log(meta.value?.count)  // Total items
console.log(meta.value?.pages)  // Total pages
console.log(meta.value?.page)   // Current page

// Change page using helper function
const goToPage = (page: number) => {
  handlePageChange(page) // ✅ Auto-refetches
}

// Change ordering using helper function
const sortByName = () => {
  handleOrderingChange({ field: 'name' }, 'asc') // ✅ Auto-refetches
}

// Or modify reactive objects directly
filters.active = false        // ✅ Auto-refetches
pagination.page = 2           // ✅ Auto-refetches
ordering.push({ created_at: 'desc' }) // ✅ Auto-refetches
</script>

<template>
  <div>
    <div v-if="meta">
      <p>Total: {{ meta.count }} items</p>
      <p>Page {{ meta.page }} of {{ meta.pages }}</p>
    </div>
    
    <ul>
      <li v-for="user in users" :key="user.id">{{ user.name }}</li>
    </ul>
    
    <button @click="goToPage(2)">Go to page 2</button>
  </div>
</template>
```

**Custom Data Key:**

If your API uses a different key name for the data array:

```typescript
// API returns { items: [...], count: 100, pages: 10 }
const { data } = usePaginatedListUsers(
  { filters: { active: true } },
  { dataKey: 'items' } // Extract from 'items' instead of 'results'
)
```

**Single Ordering Mode:**

When `enableSingleOrdering: true`, only one column can be ordered at a time:

```typescript
const { handleOrderingChange } = usePaginatedListUsers(
  { filters: { active: true } },
  { enableSingleOrdering: true }
)

// Order by name - resets all other orderings
handleOrderingChange({ field: 'name' }, 'asc')

// Order by created_at - resets name ordering
handleOrderingChange({ field: 'created_at' }, 'desc')

// Remove ordering
handleOrderingChange({ field: 'name' }, 'none')
```

### Mutation Actions (POST/PUT/PATCH/DELETE)

Mutation actions are **always manual** - they don't auto-execute on mount and don't have reactive parameters.

#### `useCreate` - Create Entity

Creates a new entity.

**Signature:**
```typescript
useCreate(options?: UseCreateActionOptions): UseCreateActionReturn<T>
```

**Parameters:**

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Type</th>
      <th>Required</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>options</code></td>
      <td><code>UseCreateActionOptions</code></td>
      <td>No</td>
      <td>Mutation options (see below)</td>
    </tr>
  </tbody>
</table>

**Returns:**

```typescript
{
  data: ShallowRef<T | null>,      // Created entity
  error: ShallowRef<Error | null>, // Error if request failed
  isLoading: Readonly<ShallowRef<boolean>>, // Loading state
  execute: (payload: Partial<T>) => Promise<void> // Execute function
}
```

**Example:**

```vue
<script setup>
import { ref } from 'vue'
import { useUsers } from '@/composables/useUsers'

const { useCreateUser } = useUsers()
const { data, error, isLoading, execute: createUser } = useCreateUser()

const name = ref('')
const email = ref('')

const handleSubmit = async () => {
  await createUser({
    name: name.value,
    email: email.value
  })
}
</script>
```

#### `useUpdate` - Update Entity

Updates an existing entity. Supports partial updates (PATCH) and full replacement (PUT).

**Signature:**
```typescript
useUpdate(options?: UseUpdateActionOptions): UseUpdateActionReturn<T>
```

**Parameters:**

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Type</th>
      <th>Required</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>options</code></td>
      <td><code>UseUpdateActionOptions</code></td>
      <td>No</td>
      <td>Mutation options (see below)</td>
    </tr>
  </tbody>
</table>

**Returns:**

```typescript
{
  data: ShallowRef<T | null>,      // Updated entity
  error: ShallowRef<Error | null>, // Error if request failed
  isLoading: Readonly<ShallowRef<boolean>>, // Loading state
  execute: (
    pk: string | number,
    payload: Partial<T>,
    executeOptions?: UseUpdateExecuteOptions
  ) => Promise<void>
}
```

**UseUpdateExecuteOptions:**

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Type</th>
      <th>Required</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>partialUpdate</code></td>
      <td><code>boolean</code></td>
      <td>No</td>
      <td><code>true</code></td>
      <td>true = PATCH (partial), false = PUT (full replacement)</td>
    </tr>
  </tbody>
</table>

**Example:**

```vue
<script setup>
import { ref } from 'vue'
import { useUsers } from '@/composables/useUsers'

const { useUpdateUser } = useUsers()
const { data, error, isLoading, execute: updateUser } = useUpdateUser()

const userId = ref(1)
const newName = ref('')

// Partial update (PATCH) - default
const handlePartialUpdate = async () => {
  await updateUser(
    userId.value,
    { name: newName.value },
    { partialUpdate: true } // Optional, true by default
  )
}

// Full replacement (PUT)
const handleFullUpdate = async () => {
  await updateUser(
    userId.value,
    {
      id: userId.value,
      name: newName.value,
      email: 'new@email.com',
      enabled: true
    },
    { partialUpdate: false } // Use PUT
  )
}
</script>
```

#### `useDelete` - Delete Entity

Deletes an entity.

**Signature:**
```typescript
useDelete(options?: UseDeleteActionOptions): UseDeleteActionReturn<T>
```

**Parameters:**

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Type</th>
      <th>Required</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>options</code></td>
      <td><code>UseDeleteActionOptions</code></td>
      <td>No</td>
      <td>Mutation options (see below)</td>
    </tr>
  </tbody>
</table>

**Returns:**

```typescript
{
  data: ShallowRef<T | null>,      // Deleted entity (if server returns it)
  error: ShallowRef<Error | null>, // Error if request failed
  isLoading: Readonly<ShallowRef<boolean>>, // Loading state
  execute: (pk: string | number) => Promise<void>
}
```

**Example:**

```vue
<script setup>
import { ref } from 'vue'
import { useUsers } from '@/composables/useUsers'

const { useDeleteUser } = useUsers()
const { error, isLoading, execute: deleteUser } = useDeleteUser()

const userId = ref(1)

const handleDelete = async () => {
  if (confirm('Are you sure?')) {
    await deleteUser(userId.value)
  }
}
</script>
```

### Action Options

#### QueryActionOptions

Options for query actions (`useRetrieve`, `useList`).

<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>Type</th>
      <th>Required</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>onMount</code></td>
      <td><code>boolean</code></td>
      <td>No</td>
      <td><code>true</code></td>
      <td>Automatically execute on component mount</td>
    </tr>
    <tr>
      <td><code>autoUpdate</code></td>
      <td><code>boolean | Ref | ComputedRef</code></td>
      <td>No</td>
      <td><code>true</code></td>
      <td>Automatically refetch when reactive parameters change</td>
    </tr>
    <tr>
      <td><code>initialData</code></td>
      <td><code>T | null</code></td>
      <td>No</td>
      <td><code>null</code></td>
      <td>Initial data before request completes</td>
    </tr>
    <tr>
      <td><code>deduplication</code></td>
      <td><code>boolean</code></td>
      <td>No</td>
      <td><code>undefined</code></td>
      <td>Enable request deduplication (overrides global setting)</td>
    </tr>
    <tr>
      <td><code>throwOnError</code></td>
      <td><code>boolean</code></td>
      <td>No</td>
      <td><code>false</code></td>
      <td>Whether to throw errors instead of storing them in the error ref</td>
    </tr>
  </tbody>
</table>

**Example:**

```typescript
const { data, execute } = useListUsers(
  { filters: { enabled: true } },
  {
    onMount: false,        // Don't fetch on mount
    autoUpdate: false,     // Don't auto-refetch when filters change
    deduplication: true    // Enable deduplication for this action
  }
)
```

**Example with Reactive Objects:**

```typescript
const { data, execute, filters, pagination, ordering } = useListUsers(
  { 
    filters: { enabled: true },
    pagination: { page: 1, pageSize: 20 },
    ordering: [{ name: 'asc' }]
  },
  {
    onMount: true,          // Fetch on mount
    autoUpdate: true,       // Auto-refetch when reactive objects change
    deduplication: true     // Enable deduplication for this action
  }
)

// Modifying reactive objects will trigger automatic refetch (because autoUpdate: true)
filters.enabled = false        // ✅ Auto-refetches
pagination.page = 2            // ✅ Auto-refetches
ordering.push({ created_at: 'desc' }) // ✅ Auto-refetches
```

#### MutationActionOptions

Options for mutation actions (`useCreate`, `useUpdate`, `useDelete`).

<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>Type</th>
      <th>Required</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>throwOnError</code></td>
      <td><code>boolean</code></td>
      <td>No</td>
      <td><code>false</code></td>
      <td>Whether to throw errors instead of storing them in the error ref</td>
    </tr>
  </tbody>
</table>

**Example**

```typescript
import { useCreditNotes } from '@/composables/useCreditNotes'

const { useCreateCreditNote } = useCreditNotes()

const { execute: createCreditNote } = useCreateCreditNote({
  throwOnError: true // Throw errors instead of storing in error ref
})
```

### Manual Execution

All actions support manual execution by setting `onMount: false` and calling `execute()` when needed.

**Basic Manual Execution:**

```typescript
const { data, execute, isLoading } = useListUsers(
  { filters: { enabled: true } },
  { onMount: false } // Don't fetch on mount
)

// Trigger fetch manually
const loadUsers = async () => {
  await execute()
}
```

**Manual Execution with Different Parameters:**

Since `execute()` doesn't accept parameters, modify the reactive objects returned by `useList` before calling `execute()`:

```typescript
const { data, execute, isLoading, filters, pagination, ordering } = useListUsers(
  { 
    filters: { enabled: true },
    pagination: { page: 1, pageSize: 20 },
    ordering: [{ name: 'asc' }]
  },
  { 
    onMount: false,     // Don't fetch on mount
    autoUpdate: false   // Disable auto-refetch (manual control)
  }
)

// First fetch with initial parameters
const loadFirstPage = async () => {
  filters.enabled = true
  pagination.page = 1
  await execute()  // Fetches page 1 with enabled=true
}

// Second fetch with different parameters
const loadSecondPage = async () => {
  filters.enabled = false  // Different filter
  pagination.page = 2       // Different page
  await execute()  // Fetches page 2 with enabled=false
}

// Alternative: If autoUpdate is true, just modify reactive objects (no need to call execute)
const { data: autoData, isLoading: autoLoading, filters: autoFilters, pagination: autoPagination } = useListUsers(
  { 
    filters: { enabled: true },
    pagination: { page: 1, pageSize: 20 }
  },
  { 
    onMount: false,
    autoUpdate: true  // Auto-refetch when reactive objects change
  }
)

// Modifying reactive objects will automatically trigger refetch
autoFilters.enabled = false  // ✅ Auto-refetches
autoPagination.page = 2     // ✅ Auto-refetches
```

**Alternative: Multiple Instances**

If you need completely independent queries with different parameters, create separate instances:

```typescript
// First instance
const { data: enabledUsers, execute: loadEnabled } = useListUsers(
  { filters: { enabled: true } },
  { onMount: false }
)

// Second instance
const { data: disabledUsers, execute: loadDisabled } = useListUsers(
  { filters: { enabled: false } },
  { onMount: false }
)

// Execute independently
await loadEnabled()   // Fetches enabled users
await loadDisabled()  // Fetches disabled users
```

---

## Error Handling Patterns

The `@fiscozen/data` package provides flexible error handling through reactive `error` refs and optional exception throwing. Choose the pattern that best fits your application's needs.

### Default Behavior: Reactive Error Handling

By default, errors are stored in the `error` ref and **do not throw exceptions**. This allows you to handle errors reactively in your components.

**Query Actions (useList, useRetrieve):**

```typescript
import { useUsers } from '@/composables/useUsers'

const { useListUsers } = useUsers()
const { data, error, isLoading } = useListUsers()

// Check error reactively in template
// <div v-if="error">{{ error.message }}</div>

// Or watch for errors
watch(error, (newError) => {
  if (newError) {
    console.error('Failed to load users:', newError.message)
  }
})
```

**Mutation Actions (useCreate, useUpdate, useDelete):**

```typescript
const { data, error, isLoading, execute } = useCreateUser()

const handleCreate = async () => {
  await execute({ name: 'John', email: 'john@example.com' })
  
  // Check error after execution
  if (error.value) {
    // Handle error (show toast, log, etc.)
    showToast({ type: 'error', message: error.value.message })
    return
  }
  
  // Success - error.value is null
  showToast({ type: 'success', message: 'User created!' })
}
```

### Global Error Handler

Use Vue's `watch` to handle errors globally across your application:

```typescript
import { watch } from 'vue'
import { useUsers } from '@/composables/useUsers'

const { useListUsers } = useUsers()
const { error } = useListUsers()

watch(error, (newError) => {
  if (newError) {
    // Show toast notification
    showToast({ type: 'error', message: newError.message })
    
    // Log to error tracking
    Sentry.captureException(newError)
  }
})
```

### Exception-Based Error Handling (throwOnError: true)

Enable exception throwing for traditional try/catch patterns:

**Per-Action Error Handling:**

```typescript
const { execute } = useCreateUser({ throwOnError: true })

const handleCreate = async () => {
  try {
    await execute({ name: 'John' })
    // Success
    showToast({ type: 'success', message: 'User created!' })
  } catch (err) {
    // Handle error
    if (err instanceof Error && err.message.includes('duplicate')) {
      // Handle duplicate error specifically
      showToast({ type: 'error', message: 'User already exists' })
    } else {
      // Handle other errors
      showToast({ type: 'error', message: err.message })
    }
  }
}
```

**Query Actions with throwOnError:**

```typescript
const { data, error, execute } = useListUsers(
  { filters: { enabled: true } },
  { throwOnError: true }
)

const loadUsers = async () => {
  try {
    await execute()
    // Success - data.value contains the result
  } catch (err) {
    // Error - err contains the error, error.value also contains it
    console.error('Failed to load users:', err)
  }
}
```

### Error Handling Best Practices

**✅ Recommended: Use reactive error handling for UI feedback**

```typescript
// Template
<template>
  <div v-if="error" class="error-message">
    {{ error.message }}
  </div>
  <div v-if="isLoading">Loading...</div>
  <div v-else>{{ data }}</div>
</template>

<script setup>
const { data, error, isLoading } = useListUsers()
</script>
```

**✅ Use throwOnError for programmatic error handling**

```typescript
// When you need to handle errors in async functions
const processUsers = async () => {
  const { execute } = useListUsers({ throwOnError: true })
  
  try {
    await execute()
    // Continue with processing
  } catch (err) {
    // Handle error and stop processing
    return
  }
}
```

---

## TypeScript Best Practices

**Define Entity Types:**

```typescript
// src/types/user.ts
export interface User {
  id: number
  name: string
  email: string
  enabled: boolean
  createdAt: string
  updatedAt: string
}
```

**Use in Composable:**

```typescript
import { useActions } from '@fiscozen/data/rest'
import type { User } from '@/types/user'

export const useUsers = () => {
  const { useRetrieve, useList, useCreate, useUpdate, useDelete } = 
    useActions<User>('users')
  
  return {
    useRetrieveUserById: useRetrieve,
    useListUsers: useList,
    useCreateUser: useCreate,
    useUpdateUser: useUpdate,
    useDeleteUser: useDelete
  }
}
```

**Type Safety in Components:**

```vue
<script setup lang="ts">
import { useUsers } from '@/composables/useUsers'
import type { User } from '@/types/user'

const { useListUsers } = useUsers()
const { data: users } = useListUsers()

// users is typed as ShallowRef<User[] | null>
users.value?.forEach((user: User) => {
  console.log(user.name) // TypeScript knows user.name exists
})
</script>
```

---

## Testing

**Unit Test Entity Composable:**

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { setupFzFetcher, resetFzFetcher } from '@fiscozen/data/rest'
import { useUsers } from './useUsers'

describe('useUsers', () => {
  beforeEach(() => {
    resetFzFetcher()
    setupFzFetcher({
      baseUrl: 'https://api.test.com/v1',
      csrf: { enabled: false }
    })
  })

  it('should list users', async () => {
    global.fetch = vi.fn(() =>
      Promise.resolve(
        new Response(JSON.stringify([{ id: 1, name: 'John' }]), {
          status: 200,
          headers: { 'Content-Type': 'application/json' }
        })
      )
    ) as any

    const { useListUsers } = useUsers()
    const { data, execute } = useListUsers({ onMount: false })
    
    await execute()
    
    expect(data.value).toEqual([{ id: 1, name: 'John' }])
  })
})
```

---

## Features

### ✅ Available Features (v1.0)

- **Complete CRUD Operations** - `useRetrieve`, `useList`, `useCreate`, `useUpdate`, `useDelete`
- **Reactive Parameters** - `useList` and `usePaginatedList` return reactive objects (`filters`, `pagination`, `ordering`) for direct modification. Automatic refetching when reactive objects change or when `pk` changes in `useRetrieve`
- **Call-with-defaults helpers** - `callListActionWithDefaults`, `callPaginatedListActionWithDefaults`, `callRetrieveActionWithDefaults`, `callCreateActionWithDefaults`, `callUpdateActionWithDefaults`, `callDeleteActionWithDefaults` (call action with default args merged with additional from the view)
- **Filter Semantics** - `undefined` = omit from request (e.g. remove default filter), `null` = send to server
- **CSRF Protection** - Automatic token injection for mutation requests
- **Request Deduplication** - Prevent duplicate identical requests
- **Request/Response Interceptors** - Modify requests/responses or abort requests
- **Reactive body and headers in useFzFetch** - `body` and `headers` accept `MaybeRefOrGetter` and are re-evaluated on each `execute()`, so you can pass a ref or computed for the payload
- **Debug Logging** - Development logging for troubleshooting
- **TypeScript Support** - Full type safety with generics
- **Error Handling** - Consistent error states across all actions
- **Loading States** - Built-in loading state management

### 🔮 Nice to Have (Future)

- **Request Timeouts** - Configurable timeouts (global and per-action) to abort requests that exceed configured duration
- Response caching and cache invalidation
- Optimistic updates for mutations
- Retry logic with exponential backoff
- Devtools integration
- Mock/test utilities
- File upload support with progress tracking
- Response pagination metadata parsing
- Offline support with request queue

---

## Future Enhancements

The current architecture is designed to support future protocol adapters:

### GraphQL Support

The package structure allows for a future `@fiscozen/data/graphql` adapter that would:

- Use the same `useActions` pattern
- Provide GraphQL-specific composables (`useQuery`, `useMutation`, `useSubscription`)
- Share the same setup and configuration pattern
- Maintain type safety with GraphQL code generation

**Example (future):**
```typescript
import { useActions } from '@fiscozen/data/graphql'

const { useQuery, useMutation } = useActions<User>('users')

// GraphQL query
const { data } = useQuery(gql`
  query GetUsers($enabled: Boolean!) {
    users(enabled: $enabled) {
      id
      name
      email
    }
  }
`, { enabled: true })
```

### WebSocket Support

A future `@fiscozen/data/websocket` adapter could provide:

- Real-time subscriptions
- Automatic reconnection
- Message queuing
- Integration with existing REST actions

**Example (future):**
```typescript
import { useSubscription } from '@fiscozen/data/websocket'

// Real-time user updates
const { data, error } = useSubscription('users:updated', {
  onMessage: (user) => {
    // Handle real-time update
  }
})
```

---

## Summary

The `@fiscozen/data` package provides a clean, type-safe, and reactive data layer for Vue 3 applications. By following the three-step pattern (Setup → Entity Composable → Component Usage), you can:

- Keep components focused on presentation
- Centralize API logic in reusable composables
- Leverage automatic refetching with reactive parameters
- Handle errors and loading states consistently
- Maintain full type safety with TypeScript
